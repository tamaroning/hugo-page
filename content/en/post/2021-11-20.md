---
title: "コンパイラ最適化を実装する"
date: 2021-11-20T05:00:00+09:00
draft: false
langauge: "ja"
toc: true
summary: " "
tags: ["Compiler"]
---

## はじめに

自作したインタプリタにいくつかのコンパイラ最適化を実装したので、そのときのメモを残しておく。

作ったもの

[https://github.com/tamaroning/haribote-lang:embed:cite]

入力したプログラムは以下の順で処理される。

1. Lex : プログラムをトークン列に変換
2. Parse : トークン列を中間表現に変換
3. Optimize : 中間表現に手を加えて最適化する
4. Execute : 中間表現を実行する

このインタプリタでは構文木を介さずにトークン列から直接的に中間表現に変換している。中間表現はLLVM IRのサブセットに近い。

以下ではOptimizeについて詳しく見ていく

## コンパイラ最適化とは
コンパイル過程において中間表現/構文木をより良い中間表現/構文木に変換すること。

主な目的は

- 命令数が少ない (バイナリのサイズを減らす)
- 実行速度を速くする

LLVMやGCCなどが有名。

## アプローチ
最適化を行うためには、まず中間表現全体の静的な解析が必要。

静的解析は以下の二つにわけられる。

- 制御フロー解析 (Control-flow analysis)
- データフロー解析 (Data-flow analysis)

## 制御フロー解析
プログラムを基本ブロック(Basic block)と辺(Edge)からなる有向グラフに変換する。
基本ブロック内では、前から後ろに一直線に処理が走る。辺には基本ブロック間の処理の移動を表す。
基本ブロックの最後に、条件分岐や無条件分岐がある場合は、その場所から別の基本ブロックへ辺が作られる。(条件分岐では一つのノードから二本の辺が出ることになる) こうしてできたグラフを制御フローグラフ(Control-flow graph: CFG)という。

## データフロー解析
具体的な最適化を行うために必要な情報を、制御フローグラフを用いて収集する。

例えば、あるノード`a = x` に対して定数伝播/畳み込み(後述)を行う場合、 *x* が定数であるという情報が必要である。この場合は、どのような制御フローを介してノードに到達しても、必ずそのノードでは *x=C* で一定であることを証明することになる。

一般的にサイクリックな制御フローの解析は難しい。

## 実際に実装した最適化
- 覗き穴最適化 (Peekhole Optimization)
- 定数伝播 (Constant Propagation)
- 定数畳み込み (Constant Folding)
- 到達不可能コードの削除

### 覗き穴最適化
以下のような変換を行う。

before
``` c
goto A;
A:
goto B;
B:
/* 何らかの処理 */ 
```

after
``` c
goto B;
A:
goto B;
B:
/* 何らかの処理 */
```
まず、1行目の`goto A`を見る。ジャンプ先Aではさらに無条件分岐`goto B`が呼ばれているので、`goto A`の最終的なジャンプ先はBである。
`goto A`は`goto B`で置き換えられる。

同様に、3行目の`goto B`の最終的なジャンプ先はBだが、これは命令を置き換えなくても済む。
#### 実装
制御フローグラフを構築しなくてもよく、分岐先を再帰的に辿ることでできる。ただし、`A: goto A`のように循環する場合を検出する必要がある。

### 定数伝播 &定数畳み込み
定数伝播と定数畳み込みはコンパイル時に定数を計算するためのテクニックである。
以下のような置き換えを行う。

before
``` c
a = 2;
b = a * 3;
c = b + 4;
```

after
```
a = 2;
b = 6;
c = 10;
```

この場合は、以下のステップごとに行われる。

1. 1行目: a = 2は定数
2. 2行目: a は 2 で置き換える (伝播)
3. 2行目: b = 2 * 3 = 6 を計算する (畳み込み)
4. 3行目: b = 6 で置き換える (伝播)
5. 3行目: c = 6 + 4 を計算する (畳み込み)

#### 実装
上の例では処理が上から下に一直線に行われる、つまり基本ブロック内で行われる最適化である。この場合、変数と値のテーブルを使うことで簡単に実装ができる。

一方で複雑な制御フローが絡む大局的な定数伝播はもっと難しい。制御フローグラフの各ノードごとに変数と値のテーブルを持たせることで、効率的に行うことができる。詳しくは[[ref1]](http://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html)を見てほしい。

### 到達不可能コードの削除 (DCE)

以下の変換をする最適化である。

before
``` c
goto A;
a = 10;
A:
```

after
``` c
goto A;
A:
```
2行目の`a = 10`は必ず実行されない命令(到達不可能コード)だから、削除することでバイナリのサイズを減らすことができる。もちろん、ここからさらに、`goto A; A:`を削除することもできる。

#### 実装
制御フローグラフの各ノードに対して、到達可能を表すboolean値を持たせる。制御フローグラフのエントリーポイントからグラフの全探索を行い、到達したノードのboolean値を
trueにする。最後にfalseなノードを削除する。

##　Refs
- [1] http://pages.cs.wisc.edu/~horwitz/CS704-NOTES/2.DATAFLOW.html


